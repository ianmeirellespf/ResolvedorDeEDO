import numpy as np
import matplotlib.pyplot as plt

def semi_implicit_euler_method(t0, tf, dt, x0, v0, f, g):
    num_steps = int((tf - t0) / dt)+1
    t = np.linspace(t0, tf, num_steps)
    x = np.zeros_like(t)
    v = np.zeros_like(t)
    print(t)
    x[0] = x0
    v[0] = v0
    for i in range(1, num_steps):
        v[i] = v[i-1] + dt * f(t[i-1], x[i-1])
        x[i] = x[i-1] + dt * g(t[i], v[i])
    return t, x     

def euler_method(t0, tf, dt, x0, v0, f, g):
    num_steps = int((tf - t0) / dt)+1
    t = np.linspace(t0, tf, num_steps)
    x = np.zeros_like(t)
    v = np.zeros_like(t)
    x[0] = x0
    v[0] = v0

    for i in range(1, num_steps):
        v[i] = v[i-1] + dt * f(t[i-1], x[i-1])
        x[i] = x[i-1] + dt * g(t[i-1], v[i-1])
    
    return t, x

def verlet_method(t0, tf, dt, x0, v0, f):
    num_steps = int((tf - t0) / dt)+1
    t = np.linspace(t0, tf, num_steps)
    x = np.zeros_like(t)
    v = np.zeros_like(t)
    x[0] = x0
    v[0] = v0
    x[1]=x[0]+v[0]*dt+0.5*f(t[0], x[0])*dt**2
    for i in range(2, num_steps):
        x[i] = 2*x[i-1] - x[i-2] + dt**2 * f(t[i-1], x[i-1])
        
    return t, x

def runge_kutta_method(t0, tf, dt, x0, v0, f, g):
    num_steps = int((tf - t0) / dt)+1
    t = np.linspace(t0, tf, num_steps)
    x = np.zeros_like(t)
    v = np.zeros_like(t)
    x[0] = x0
    v[0] = v0

    for i in range(1, num_steps):
        k11 = g(t[i-1], v[i-1])
        k12 = f(t[i-1], x[i-1])
        k21 = g(t[i-1] + 0.5*dt, v[i-1] + 0.5*k11*dt)
        k22 = f(t[i-1] + 0.5*dt, x[i-1] + 0.5*k12*dt)
        k31 = g(t[i-1] + 0.5*dt, v[i-1] + 0.5*k21*dt)
        k32 = f(t[i-1] + 0.5*dt, x[i-1] + 0.5*k22*dt)
        k41 = g(t[i-1] + dt, v[i-1] + k31*dt)
        k42 = f(t[i-1] + dt, x[i-1] + k32*dt)
        v[i] = v[i-1] + (k12 + 2*k22 + 2*k32 + k42)*dt / 6
        x[i] = x[i-1] + (k11 + 2*k21 + 2*k31 + k41)*dt / 6
    
    return t, x

def leapfrog_method(t0, tf, dt, x0, v0, f):
    num_steps = int((tf - t0) / dt)+1
    t = np.linspace(t0, tf, num_steps)
    x = np.zeros_like(t)
    v = np.zeros_like(t)
    x[0] = x0
    v[0] = v0

    for i in range(1, num_steps):
        x[i] = x[i-1] + dt * v[i-1] + 0.5 * dt**2 * f(t[i-1], x[i-1])
        v[i] = v[i-1] + dt * (f(t[i-1], x[i-1]) + f(t[i], x[i])) / 2
    
    return t, x

# Exemplo de EDO
# Exemplo de EDO - Movimento Harmônico Simples
def f(t, x): #v'= f(t,x)
    k = 1.0  # constante da mola
    m = 1.0  # massa
    return -k * x / m
def g(t,v): #x'=g(t,v)
    return v



# Parâmetros iniciais
t0 = 0.0
tf = 10.0
dt = 0.01
x0 = 1.0  # posição inicial
v0 = 0.0  # velocidade inicial

# Resolvendo usando o método de Euler semi-implicito
t_euler_semi, x_euler_semi = semi_implicit_euler_method(t0, tf, dt, x0, v0, f, g)
# Resolvendo usando o método de Euler
t_euler, x_euler = euler_method(t0, tf, dt, x0, v0, f, g)
# Resolvendo usando o método de Verlet
t_verlet, x_verlet = verlet_method(t0, tf, dt, x0, v0, f)
# Resolvendo usando o método de Runge-Kutta
t_rk4, x_rk4 = runge_kutta_method(t0, tf, dt, x0, v0, f, g)
# Resolvendo usando o método de Leapfrog
t_leapfrog, x_leapfrog = leapfrog_method(t0, tf, dt, x0, v0, f)

# Plotando os resultados
plt.plot(t_euler_semi,x_euler_semi,color='black',label='euler semi-implicito')
plt.plot(t_euler, x_euler,color= 'green', label='Euler')
plt.plot(t_verlet, x_verlet,color= 'blue', label='Verlet')
plt.plot(t_rk4, x_rk4,'m-.',color= 'red', label='Runge-Kutta')
plt.plot(t_leapfrog, x_leapfrog,'m-.',color= 'magenta', label='Leapfrog')
plt.xlabel('Tempo')
plt.ylabel('Posição')
plt.legend()
plt.show()